# Chapter 4

## 커넥션 관리

> 들어가며

- HTTP가 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

## 1. TCP 커넥션

TCP/IP는 패킷 교환 네트워크 프로토콜들의 계층화된 집합이다.  
전세계 모든 HTTP 통신은 TCP/IP 커넥션을 통해 전달된다.  
커넥션이 맺어지면 클러아인트와 서버 간에 주고받는 메세지는 손실이나 손상, 순서가 바뀌지 않고 안전하게 전달된다.

TCP를 통한 HTTP 통신은 다음과 같이 이뤄진다.

1. 브라우저가 "http:///joes-hardware.com:80/power-tools.html" URL에 접속
2. 브라우저가 호스트명 www.joes-hardware.com 추출
3. 브라우저가 포트 번호 80 추출
4. 브라우저가 202.43.78.3의 80포트로 TCP 커넥션 생성
5. 브라우저가 서버로 HTTP GET 요청 메세지 보냄
6. 브라우저가 서버에서 온 HTTP 응답 메세지 읽음
7. 브라우저가 커넥션 끊음

### 1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

HTTP 커넥션은 대부분 TCP 커넥션이다.  
안전한 데이터 전송 방식이 궁금하다면 먼저 TCP에 대해 알아야 한다.

### 1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.

HTTP는 HTTP, HTTPS 프로토콜 스택의 최상위 계층이다.

| HTTP 프로토콜 스택                    |
| ------------------------------------- |
| HTTP : 애플리케이션 계층              |
| TCP : 전송 계층                       |
| IP : 네트워크 계층                    |
| Network Interfaces : 데이터 링크 계층 |

<br>

| HTTPS 프로토콜 스택                   |
| ------------------------------------- |
| HTTP : 애플리케이션 계층              |
| TLS/SSL : 보안 계층                   |
| TCP : 전송 계층                       |
| IP : 네트워크 계층                    |
| Network Interfaces : 데이터 링크 계층 |

<br>

HTTP가 메세지를 전송 할 때 다음의 과정을 거친다.

- TCP 커넥션으로 메세지 데이터 순서대로 전송
- TCP가 세그먼트 단위로 데이터 스트림 나눔
- 세그먼트를 IP 패킷에 담아 인터넷 통해 전달

이 과정은 TCP/IP 소프트웨어에 의해 처리된다.

각 IP 패킷은 다음의 정보를 가진다.

- IP 패킷 헤더
  - 발신지·목적지 IP 주소, 기타 플래그
- TCP 세그먼트 헤더
  - TCP 포트번호, TCP 제어 플래그, 데이터 순서, 무결성 검사 값
- TCP 데이터 조각

### 1.3 TCP 커넥션 유지하기

컴퓨터는 포트 번호를 통해 여러 개의 커넥션을 유지한다.  
TCP 커넥션은 4가지 값으로 생성된다.

- 발신지 IP 주소
- 발신지 포트
- 수신지 IP 포트
- 수신지 포트

이 중 하나의 값이라도 다르면 다른 TCP 커넥션이 생성된다.

### 1.4 TCP 소켓 프로그래밍

소켓 API는 TCP 종단 데이터 구조 생성하고, 원격 서버의 TCP 종단에 데이터 구조 연결해 데이터 스트림을 읽고 쓴다.

소켓 API는 핸드셰이킹, TCP 데이터와 IP 패킷 간 분활 및 재조립에 대한 세부사항을 숨긴다.

클라이언트와 서버는 아래의 과정으로 소켓 인터페이스를 통해 소통한다.

| 클라이언트              | 서버                     |
| ----------------------- | ------------------------ |
| <br>                    | 새로운 소켓 생성         |
| <br>                    | 80 포트로 소켓 묶기      |
| <br>                    | 소켓 커넥션 허가         |
| <br>                    | 커넥션 기다리기          |
| IP 주소와 포트를 얻는다 | <br>                     |
| 새로운 소켓 생성        | <br>                     |
| 서버의 ip:포트로 연결   | <br>                     |
| <br>                    | 애플리케이션 커넥션 통지 |
| <br>                    | 요청 읽기 시작           |
| 성공적으로 연결         | <br>                     |
| HTTP 요청 보내기        | HTTP 요청 처리           |
| HTTP 요청 기다리기      | <br>                     |
| <br>                    | HTTTP 응답 보내기        |
| HTTP 응답 처리          | <br>                     |
| 커넥션 닫기             | 커넥션 닫기              |

## 2. TCP의 성능에 대한 고려

HTTP 트랜잭션의 성능은 바로 아래 계층인 TCP 성능에 영향을 받는다.  
TCP 성능에 대해 이해함으로써 HTTP 커넥션에 대한 최적화 요소를 알고 좋은 성능의 HTTP 앱 설계를 할 수 있다.

### 2.1 HTTP 트랜잭션 지연

> HTTP 트랜잭션 처리의 지연 시간은 커넥션 설정, 전송 시간의 비중이 크다.

처리 시간<<커넥션, 전송 시간

대부분의 지연은 TCP 네트워크 지연으로 발생한다.

?

### 2.2 성능 관련 중요 요소

일반적인 TCP 관련 지연들에 대해 알아본다.

- TCP 커넥션 핸드셰이크 설정
- TCP 느린 시작(slow start)
- 네이글 알고리즘
- 확인응답 지연 알고리즘
- TIME_WAIT 지연, 포트 고갈

### 2.3 TCP 커넥션 핸드셰이크 지연

TCP 커넥션을 생셩할 때, TCP는 커넥션을 위해 IP 패킷을 연속으로 교환한다.

```
클라이언트 --패킷(SYN flag)-> 서버
클라이언트 <-패킷(SYN, ACK flag)-- 서버
클라이언트 --패킷(확인응답)-> 서버
```

이러한 핸드셰이킹 과정에서 전달되는 패킷은 대부분의 경우 전송할 HTTP 요청/응답 메시지가 담길 만큼 크다.  
크기가 작은 트랜잭션에서는 50% 이상의 시간을 TCP 커넥션 생성에 소요하는 것이다.

### 2.4 확인응답 지연

> 송출 패킷이 적어 확인응답 지연이 잦아지면 지연의 원인이 된다.

TCP는 TCP 세그먼트의 무결성과 순서를 보장하기 위해 세그먼트를 수신하면 송신자에게 확인응답 패킷을 반환한다.

이 패킷은 작기 떄문에 효율적인 전송을 위해 확인응답 패킷의 전송을 지연하고, 같은 방향의 확인응답 패킷과 데이터 패킷을 묶어 함께 전송한다.

일정 시간 안에 데이터 패킷을 찾지 못하면 확인응답만 별도 패킷으로 전송한다.

요청-응답으로 동작하는 HTTP 통신상, 확인응답 지연이 자주 발생하여 지연 시간이 증가할 수 있다.

### 2.5 TCP 느린 시작(slow start)

> TCP 커넥션은 갑작스러운 혼잡을 방지하기 위해 초반 전송 속도를 제한한다.

TCP 커넥션은 생성 후 1개 , 2개, 4개, ...로 1개에서 시작해 트랜잭션마다 전송 패킷 개수를 2배씩 늘린다.

이 기능 때문에 새로운 커넥션은 어느 정도 데이터를 주고받은 '튜닝'된 커넥션보다 느리다.

### 2.6 네이글 알고리즘과 TCP_NODELAY

> 네이글 알고리즘은 확인응답 대기/데이터 모으기로 인한 지연을 발생시킨다.

단 1바이트의 데이터를 전송하더라도 TCP 세그먼트는 **_40바이트 상당의 플래그와 헤더_**를 포함한다.  
따라서 아주 작은 데이터의 패킷을 다수 보내면 네트워크 성능은 크게 떨어진다.

네이글 알고리즘은 네트워크 효율을 위해 많은 양의 데이터를 합쳐 전송한다.

네이글 알고리즘은 아직 확인응답을 받지 않은 패킷(전송완료x)이 있다면, 세그먼트가 최대 크기가 될 때까지 전송을 하지 않는다.

이는 두 가지 문제 상황를 발생시킨다.

- 패킷 크기를 채울 때까지의 지연 시간이 크다.
- 확인 지연 알고리즘과 네이글 알고리즘을 동시에 사용하면 지연시간은 더 커진다.
  - 네이글은 확인응답이 올 때까지 데이터를 전송하지 않는다.
  - 확인응답 지연 알고리즘은 확인 응답을 100~200밀리치 지연시킨다.

TCP_NODELAY 파라미터 값을 설정하면 네이글 알고리즘을 비활성화시킬 수 있다.  
알고리즘을 비활성화 했다면 큰 데이터 단위로 패킷을 만들어야 한다.

### 2.7. TIME_WAIT의 누적과 포트 고갈

> 생성 가능한 커넥션(포트) 개수가 적으면 커넥션 생성 대기시간으로 인해 성능 측정 시 성능 저하를 발생시킨다.

TIME_WAIT 포트 고갈은 실제 상황에서는 문제가 없지만 성능 측정시에 심각한 성능 저하를 발생시킨다.

TCP 커넥션이 종료되면 종단은 커넥션의 IP/포트 번호를 기록한다.  
같은 IP/포트 번호 커넥션의 생성을 일정 시간(2MSL-2분) 동안 제한하여 이전 커넥션 패킷의 삽입을 막는다.

성능 시험을 하는 상황에서는 클라이언트 접숙 가능 IP 주소, 접속할 컴퓨터 수가 제한된다.  
서버의 포트 역시 일반적으로 기본 80번 포트를 사용한다.

<발신지 IP 주소, 발신지 포트, 수신지 IP 포트, 수신지 포트>

커넥션 생성을 위한 조합이 제한되어 서버에서 사용 가능한 커넥션 개수가 적어진다.

**1초당 사용가능 커넥션 수< 1초당 서버 트랜잭션 처리 수**  
의 상황이 생기면 TIME_WAIT 포트고갈로 인한 지연이 발생한다.

## 3. HTTP 커넥션 관리

커넥션 생성과 최적화를 위한 HTTP 기술을 살펴본다.

- HTTP Connection 헤더
- HTTP 커넥션 최적화 기술

### 3.1 흔히 잘못 이해하는 Connection 헤더

```
클라이언트-프락시 서버-캐시 서버-(...)-서버
```

HTTP 메세지는 클라이언트, 서버 사이의 중개 서버들을 거쳐 전달된다.

Connection 헤더는 인접한 두 애플리케이션 사이의 커넥션에만 적용되는 옵션을 표시한다.  
Connection 헤더 필드의 커넥션 토큰 값들은 다른 커넥션에 전달되지 않는다.

다음의 내용이 Connection 헤더 필드에 명시된다.

- HTTP 헤더 필드 명: 이 커넥션에만 해당하는 hop-by=hop 헤더들
  - 이 HTTP 헤더 필드들은 다음 커넥션에 전달 시 삭제되어야 한다.
- 임시 토큰 값: 커넷션에 대한 비표준 옵션
  - Connection 헤더와 메시지를 전달받으면 옵션들을 적용한다.
- CLOSE 값: 작업 후 커넥션 종료해야 함을 알린다.

Connection 헤더에 기술되어있지 않아도 홉별 헤더인 헤더도 있다.

### 3.2 순차적인 트랜잭션 처리에 의한 지연

하나의 웹페이지 로드에도 수 개의 객체가 필요하다.  
이 때 순차적인 커넥션을 이용하면 기술적, 사용자의 체감상 지연이 크다.

- 기술적 지연
  - 커넥션 생성 시간, slow start로 인한 지연이 생긴다.
- 체감상 지연
  - 객체 받는 중 화면의 변화가 없다.
  - 특정 브라우저의 경우 모든 객체 받을 때까지 빈 화면이다.

이러한 문제에 대한 성능 향상 기술 4가지를 알아본다.

- 병렬 커넥션
- 지속 커넥션
- 파이프라인 커넥션
- 다중 커넥션

## 4. 병렬 커넥션

> 여러 개의 TCP 커넥션을 통한 동시 HTTP 요청

클라이언트가 여러 개의 커넥션을 맺어 여러 개의 HTTP 트랜잭션을 병렬로 처리한다.

### 4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

단일 커넥션의 대역폭 제한과 커넥션이 동작하지 않는 시간을 활용하여 더 빠르게 페이지를 받을 수 있다.

각 커넥션의 지연시간을 겹치게 하면 총 지연 시간을 줄일 수 있다.

클라이언트 인터넷 대역폭이 충분하다면 여러 객체를 받을 수 있다.

### 4.2 병렬 커넥션이 항상 더 빠르지는 않다

클라이언트 대역폭이 좁다면 병렬 커넥션의 이점이 적다.

제한된 대역폭에서 여러 개의 객체를 전송받는 것은 순차적으로 받는 것 보다 더 오랜 시간이 걸릴 수 있다.

또한 다수의 커넥션은 메모리 소모가 크고 서버 측의 성능을 떨어뜨린다.

문제를 방지하기 위해 브라우저는 병렬 커넥션을 사용하지만 적은 수(4개)의 커넥션만을 허용한다.  
서버는 과도한 커넥션을 임의로 끊어낼 수 있다.

### 4.3 병렬 커넥션은 더 빠르게 '느껴질 수' 있다'

병렬 커넥션이 실제로 페이지를 빠르게 로드하지 않더라도, 사용자는 그렇게 느낄 수 있다.

사용자는 실제 소요시간과 관계없이 여러 개의 객체가 동시에 보일 때 빠르다고 느낀다.

## 5. 지속 커넥션

웹 클라이언트는 웹페이지를 불러오기 위에 같은 서버에 계속해서 요청을 보낼 것이다.(사이트 지역성)

- 지속 커넥션
  - 처리가 완료된 후에도 TCP 커넥션을 유지하고 다음 HTTP 요청에 재사용한다.
  - 클라이언트가 커넥션 끊기 전까지 유지한다.
- 비지속 커넥션
  - 처리가 끝날 때마다 커넥션을 끊는다.

지속 커넥션은 커넥션 핸드셰이킹 과정과 slow start를 회피해 지연을 줄인다.

### 5.1 지속 커넥션 VS 병렬 커넥션

| 병렬 커넥션                             | 지속 커넥션               |
| --------------------------------------- | ------------------------- |
| 각 트랜젝션의 커넥션 생성으로 인한 지연 | 커넥션을 유지해 지연 감소 |
| 각 커넥션은 slow start로 인해 성능 저하 | 튜닝된 커넥션 유지        |
| 병렬 커넥션 수의 제한                   | 필요 커넥션 수 감소       |

지속 커넥션은 병렬 커넥션과 비교해 위의 장점을 가지며 둘은 함께 사용할 때 효과적이다.

지속 커넥션에는 아래의 두 종류가 있다.

- HTTP/1.0+ : keep-alive 커넥션
- HTTP/1.1 : 지속 커넥션

### 5.2 HTTP/1.0+의 Keep-Alive 커넥션

초기 지속 커넥션인 keep-alive는 설계에 문제가 있지만 아직 많은 어츨리케이션이 keep-alive를 사용한다.

순차적인 트랜잭션과 비교해 아래의 장점을 가진다.

- 커넥션 설정 시간 단축
- slow start로 인한 지연 감소

### 5.3 Keep-Alive 동작

keep-alive는 HTTP/1.1 명세에서 빠졌지만 아직 널리 사용된다.  
따라서 HTTP 애플리케이션은 keep-alive 방식을 처리할 수 있어야 한다.

- keep-alive 커넥션을 구현한 클라이언트는 요청에  
  **Connection: Keep-Alive** 헤더를 포함시킨다.

- 다음 요청도 keep alive 커넥션으로 받고자 한다면,  
  서버는 응답메세지에 Connection: Keep-Alive 헤더를 넣어 전송한다.

* 서버의 응답에 Connection: Keep-Alive 헤더가 없으면 클라이언트는  
  서버가 커넥션을 끊을 것이라 추측한다.

### 5.4. Keep-Alive 옵션

keep-alive 응답 헤더의 옵션은 쉼표로 구분된다.  
헤더는 Connection: Keep-Alive 헤더가 있을 때만 사용할 수 있다.

- timeout : 커넥션의 유지 시간
- max: 커넥션의 유지 트랜잭션 개수
- 진단/디버깅 목적의 이름[=값] 형식의 임의 속성

이러한 요청에 대해 반드시 따르지 않아도 된다.  
keep-alive를 끊거나 keep-alive 커넥션의 처리 트랙잭션 양을 줄여도 문제 없다.

### 5.5 Keep-Alive 커넥션 제한과 규칙

- 클라이언트는 keep-alive 커넥션 사용을 위해 Connection: Keep-Alive 요청 헤더를 보내야 한다.

- 커넥션 유지를 위해 모든 메세지에 Connection: Keep-Alive 헤더를 포함해야 한다.

- Connection: Keep-Alive 응답 헤더가 없다면 클라이언트는 서버의 커넥션 종료를 예상할 수 있다.

- 커넥션 유지를 위해 엔터티 본문의 길이를 알아야 한다. 길이를 통해 기존 메세지 끝-새로운 메세지 시작점을 알 수 있다.

- 프락시와 게이트웨이는 다음 커넥션에 메세지를 전달하기 전 Connection 헤더의 모든 헤더 필드와 헤더를 제거한다.

- Connection 헤더를 인식하지 못하는 프록시 서버와 keep-alive 커넥션을 맺을 경우 문제가 발생할 수 있다. (아래 설명)

- 기술적으로 HTTP/1.0 기기의 모든 Connection 헤더 필드는 무시해야 한다.

- 클라이언트는 응답 중 커넥션이 끊어졌을 때 요청을 다시 보낼 수 있어야 한다.

### 5.6 Keep-Alive와 멍청한 프락시

여기서 멍청한 프록시는 Connection 헤더를 이해하지 않는 프록시다.

멍청한 프록시로 인한 문제는 아래의 순서로 발생한다.

1. 클라이언트는 프록시와의 keep-alive 커넥션을 요청한다.

2. 멍청한 프록시는 Connection 헤더를 지우지 않고 그대로 다음 서버에 전달한다.

3. Connection: Keep-Alive 헤더를 받은 서버는 프락시와의 keep-alive 커넥션에 동의하여 Connection: Keep-Alive 응답 헤더를 보낸다.

4. 멍청한 프락시가 메세지를 그대로 클라이언트에 전달한다.

5. 클라이언트는 클라이언트-프록시의 keep-alive 커넥션이 걸정되었다고 착각한다.  
   서버는 서버-프록시의 keep-alive 커넥션이 걸정되었다고 착각한다.

6. 서버측은 프록시와의 keep-alive 커넥션을 유지한다. 프락시는 커넥션이 끊어질 떄까지 기다린다.

7. 클라이언트가 프록시에 다음 요청을 보내지만 프락시는 요청을 에상하지 못하고 무시한다.

8. 브라우저는 자신이나 서버의 타임아웃으로 커넥션이 끊길 때까지 대기한다.

이러한 문제를 피하려면 Connection 헤더와 그 안의 해더들은 다음 서버에 전달해서는 않된다.

### 5.7 Proxy-Connection 살펴보기

Proxy-Connection은 멍청한 프록시 문제 해결을 위한 차선책이다.

프록시를 거쳐 HTTP 메세지가 전송된다면, Proxy-Connection을 사용한다.

련대의 브라우저는 Proxy-Connection를 인식하고 Connection로 바꿔 처리한다.  
멍청한 프록시가 메세지를 그대로 전달해도 서버는 Proxy-Connection을 무시하기에 문제가 생기지 않는다.

클라이언트와 서버 사이에 하나의 중개 서버만 존재한다면 Proxy-Connection이 효과가 있다. 그러나 영리한 프락시 옆에 멍청한 프락시가 있으면 같은 문제가 발생한다.

게다가 문제가 발생하는 프락시는 네트워크 상에서 보이지 않아 브라우저가 Proxy-Connection를 보내지 못하기도 한다.

### 5.8 HTTP/1.1의 지속 커넥션

HTTP/1.1의 지속 커넥션은 별도 설정 없이 기본으로 활성화되어 있다.

커넥션을 끊으려면 Connection: close 헤더를 명시해야 한다.  
Connection: close 헤더가 응답에 없다면, 응답 후에도 커넥션을 유지한다고 추정한다.

하지만 커넥션의 유지가 보장되는 것은 아니다.

### 5.9 지속 커넥션의 제한과 규칙

- 클라이언트는 커넥션 종료를 위해 마지막 요청에 Connection: close 헤더를 보낸다.

- 클라이언트는 Connection: close 헤더 전송 이후 그 커넥션에 추가 요청을 할 수 없다.

- 커넥션의 모든 메세지의 길이 정보가 정확해야 커넥션을 유지할 수 있다.

- HTTP/1.1 프락시는 클라이언트와 서버 각각에 별도의 지속 커넥션을 맺고 관리한다.

- HTTP/1.1 프락시는 클라이언트의 커넥션 관련 기능의 지원범위를 알지 못하면 지속 커넥션을 맺으면 안된다.

- HTTP/1.1 기기는 Connection 헤더값과 관계없이 커넥션을 끊을 수 있다.

- HTTP/1.1은 중간에 끊어지는 커넥션을 복구할 수 있어야 한다.

- 클라이언트는 전체 응답받기 전에 커넥션이 끊어져도 다시 요청을 보낼 수 있어야 한다.

- 하나의 사용자 클라이언트는 서버 부하를 막기 위해 2개의 지속 커넥션만을 유지한다.

## 6. 파이프라인 커넥션

HTTP/1.1은 지속 커넥션을 통해 요청을 파이프라이닝한다.  
요청에 대한 응답을 기다리지 않고 연속으로 요청을 전달해 성능을 높인다.

파이프라이닝의 제약 사항은 다음과 같다.

- HTTP 클라이언트는 지속 커넥션임을 확인하기 전까지 파이프라이닝하면 안 된다.
- HTTP 응답은 요청 순서와 같은 순서로 와야 한다.
- HTTP 클라이언트는 커넥션이 끊어져도 다시 요청할 수 있어야 한다.
- HTTP 클라이언트 POST와 같은 비멱등 요청을 파이프라인을 통해 보내면 안된다.

## 7 커넥션 끊기에 대한 미스터리

커넥션을 끊는 방법에는 명확한 기준이 없다.

### 7.1 '마음대로' 커넥션 끊기

어떤 서버, 클라이언트 프락시든 언제든지 TCP 커넥션을 끊을 수 있다.  
지속 커넥션이 일정 시간 유휴 상태에 있다면 서버는 커넥션을 끊을 수 있다.  
끊는 시점에 클라이언트가 요청을 보내고 있다면 문제가 생긴다.

### 7.2 Content-Length와 Truncation

각 HTTP 응답은 본문의 정확한 크기 값을 가지는 Content-Length 헤더를 가져야 한다.

클라이언트나 프락시가 커넥션이 끊어지졌다는 HTTP 응답을 받은 후 엔터티의 길이와 Contetn-Length 값이 일치하지 않거나 값이 없다면 수신자는 정확한 정보를 서버에 물어봐야 한다.

수신자가 캐시 프락시라면 응답을 캐시하지 않고 그대로 전달해야 한다.

### 7.3 커넥션 끊기의 허용, 재시도, 멱등성

클라이언트의 요청 중 커넥션이 끊기면, 클라이언트는 응답을 받지 못한 요청의 처리 상태를 알 수 없다.

멱등: 실행 횟수에 관계없이 동일한 결과를 도출하는 특성  
 GET, HEAD, PUT, DELETE, TRACE, OPTIONS는 멱등하다.
PUT은 비멱등하다.

- 멱등한 요청이라면 단순히 다시 요청한다.
- 비멱등인 요청을 중복 요청하게 되면 알 수 없는 결과를 초래하기에 이전 요청에 대한 응답을 기다린다.

### 7.4 우아한 커넥션 끊기

TCP 커넥션은 양방향으로 연결된다. 커넥션은 양방향 모두 끊거나 한 쪽만 끊을 수 있다.

- 서버 전체 끊기
  - close() 호출
  - 입력 출력, 채널 커넥션 모두 끊는다
- 서버 출력 절반 끊기(우아한 커넥션 끊기)
  - shutdown() 호출
  - 서버 출력 끊기
- 서버 입력 절반 끊기
  - shutdown() 호출
  - 서버 입력 끊기

> TCP 끊기와 리셋 에러

지속 커넥션을 사용할 때는 쓰기 에러를 방지하기 위해 절반 끊기를 사용해야 한다.

- 서버 출력 절반 끊기
  - 클라이언트는 모든 데이터를 버퍼에서 읽고 데이터 전송이 끝난 후 커넥션이 끊겼음을 알게 된다.
- 서버 입력 절반 끊기
  - 끊긴 입력 채널에 클라이언트가 요청을 보내면 connection reset by peer 메세지를 받는다.
  - connection reset by peer 에러가 발생하면 클라이언트 버퍼의 읽지 않은 응답 데이터가 사라진다.

따라서 서버 입력 절반 끊기가 바람직하다.

> 우아하게 커넥션 끊기

- 애플리케이션이 자신의 출력 채널을 끊는다.
- 다른 쪽 기기의 출력 채널이 끊어지기를 기다린다.

양쪽에서 출력 채널을 끊으면 리셋의 위험없이 커넥션이 종료된다.

상대방이 출력 채널을 끊었는지 확인하기 위해 어플리케이션은 절반 끊기 이후에도 주기적으로 입력 채널 상태 검사를 한다.

타임아웃 시간 내에 끊어지지 않으면 커넥션을 강제로 끊을 수 있다.
