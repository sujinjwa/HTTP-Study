# Chapter 3

## HTTP 메시지

> 들어가며

- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 기능(메소드)
- 응답 메시지가 반환하는 상태 코드
- HTTP 헤더들은 무슨 일을 하는가

## 1. 메시지의 흐름

> 메시지는 원 서버 방향을 인바운드로 하여 송신된다.

- 인바운드: 메시지가 원 서버로 향하는 방향
- 아웃바운드: 메시지가 사용자 에이전트로 돌아오는 방향

> 모든 메시지는 다운스트림으로 흐른다.

- 메시지의 발송자는 수신자의 업스트림이다.
- 메시지의 수신자는 발송자의 다운스트림이다.

## 2. 메시지의 각 부분

HTTP 메시지는 시작줄, 헤더, 본문으로 이뤄진다.

- 시작줄
  - 아스키 문자열
  - CRLF/개행문자로 끝난다.
- 헤더 블록
  - 아스키 문자열
  - CRLF/개행문자로 끝난다.
- 본문
  - 선택적인 데이터 덩어리
  - 비어있을 수 있다.

### 2.1 메시지 문법

HTTP 메시지는 요청/응답 메시지는 시작줄, 헤더, 본문으로 동일한 구조를 가진다.

> 시작줄 문법

요청 메시지와 응답 메시지가 다르다.

| 요청 메세지 시작줄 문법 | <br>                                 |
| ----------------------- | ------------------------------------ |
| 메서드                  | 서버가 리소스에 수행하길 바라는 동작 |
| 요청 URL                | 요청 리소스를 지칭하는 URL 요소      |
| 버전                    | 메세지의 HTTP 버전                   |

| 응다 메세지 시작줄 문법 | <br>                                 |
| ----------------------- | ------------------------------------ |
| 버전                    | 메세지의 HTTP 버전                   |
| 상태 코드               | 요청 중 발생한 일을 설명. 3자리 숫자 |
| 사유 구절               | 상태코드를 설명하는 문구             |

> 헤더 문법

```
이름:(선택 공백)값 CRLF
```

헤더는 0개 이상 존재한다.  
헤더 목록은 빈 줄(CRLF)로 끝난다.

> 엔터티 본문 문법

엔터티 본문은 임의의 데이터 블록을 포함한다.  
본문이 없다면 CRLF로 메시지가 끝난다.

> 주의사항

헤더나 엔터티 본문이 없어도 헤더 집합은 CRLF로 끝난다.  
그러나 이를 지키지 않는 경우가 많아 CRLF 없이 끝나는 메시지도 받아들여야 한다.

### 2.2 시작줄

시작줄의 필드는 공백으로 구분된다.

- 요청줄: 무엇을 할 지 서술
  - 메소드, URL, 버전
- 응답줄: 무슨 일이 일어났는지 서술
  - 버전, 상태 코드, 사유 구절

> 메소드

| 매소드  | 설명                                   | 메세지 본문 유무 |
| ------- | -------------------------------------- | ---------------- |
| GET     | 문서를 가져온다                        | X                |
| HEAD    | 문서 헤더만 가져온다                   | X                |
| POST    | 처리할 데이터를 보낸다                 | O                |
| PUT     | 서버에 데이터를 저장한다               | O                |
| TRACE   | 메시지가 서버에 도달하는 과정 추적한다 | X                |
| OPTIONS | 서버가 수행 가능한 메서드를 확인한다   | X                |
| DELETE  | 서버에서 문서를 제거한다               | X                |

- 모든 서버에 모든 메소드가 구현되는 것은 아니다.
- 확장 메소드가 구현되어있을 수 있다.

> 상태 코드

| 전체 범위 | 정의된 범위 | 분류            |
| --------- | ----------- | --------------- |
| 100-199   | 1000-101    | 정보            |
| 200=299   | 200-206     | 성공            |
| 300-399   | 300-305     | 리다이렉션      |
| 400-299   | 200-215     | 클라이언트 에러 |
| 500-599   | 500-505     | 서버 에러       |

- 인식할 수 없는 상태 코드는 누군가가 확장으로 정의했을 가능성이 있다.
- 그러한 코드는 포함되는 범주의 상태 코드로 가정하고 다룬다.

> 사유 구절

상태 코드에 대한 글로 된 설명이다.  
사람이 이해하기 쉽도록 하는 것이 목적이다.

> 버전 번호

HTTP/x.y 형식으로 요청줄, 응답줄 양쪽에 기술된다.  
버전 번호는 자신의 프로토콜 버전을 알려 능력과 메시지 형식에 대한 단서를 제공한다.

> 헤더

HTTP 헤더 명세는 여러 헤더 필드를 정의한다.  
HTTP 헤더는 다음과 같이 분류된다.

- 일반 헤더
  - 요청과 응답 양쪽에 나타날 수 있음
- 요청 헤더
  - 요청에 대한 부가 정보 제공
- 응답 헤더
  - 응답에 대한 부가 정보 제공
- Entity 헤더
  - 본문 크기와 콘텐츠, 혹은 리소스 그 자체 서술
- 확장 헤더
  - 명세에 정의되지 않은 새로운 헤더

헤더 예시는 다음과 같다.

```
Date: Tue, 3 Oct 1997 02:16:03 GMT
Content-length: 15040
```

헤더가 너무 길다면 다음 줄 앞에 최소 하나의 스페이스 혹은 탭을 붙여 쪼갤 수 있다.

```
HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
Server: Test Server
    version 1.0
```

> 엔터티 본문

선택적인 부분이며 이미지, 비디오, HTML, 소프트웨어 어플리케이션, 등 다양한 디지털 데이터를 실어 나를 수 있다.

### 2.5 버전 0.9 메세지

HTTP/0.9는 아주 단순한 요청-응답 프로토콜을 가지고 있는 HTTP 초기 버전이다.

HTTP/0.9 메시지는 상태코드, 사유구절, 헤더 없이 단순한 구조를 가진다.

- 요청 메시지
  - 메소드
  - 요청 URL
- 응답 메시지
  - 엔터티

이러한 단순함으로 다양한 상황에 대한 대응이 어렵다.

## 3. 메서드

서버에서 모든 메소드를 구현하지는 않는다.  
HTTP/1.1과의 호환은 GET과 HEAD 메소드의 구현으로 충분하다.

### 안전한 메서드

안전한 메서드는 메서드를 사용하는 HTTP 요청이 서버에 아무런 작용도 없음을 의미한다.

안전한 메서드를 정의하여 사용자에게 안전하지 않은 메서드의 사용을 알릴 수 있다.

| 메서드 | 멱등성 | 안전 |
| ------ | ------ | ---- |
| GET    | O      | O    |
| HEAD   | O      | O    |
| PUT    | O      | X    |
| DELETE | O      | X    |
| POST   | X      | X    |
| PATCH  | X      | X    |

멱등성은 모든 안전한 메소드는 멱등성을 갖지만, 그 역은 성립하지 않는다.  
모든 안전한 메소드는 멱등성을 갖지만, 그 역은 성립하지 않는다.

### GET

> 서버에 리소스 요청한다.

HTTP/1.1를 위해서 서버는 GET 메소드를 구현해야 한다.

### HEAD

> 리소스의 헤더만을 반환한다.

HTTP/1.1를 위해서 서버는 HEAD 메소드를 구현해야 한다.

GET과 같은 동작을 하지만, 헤더만을 반환한다.  
HEAD 메서드를 사용해 다음의 작업을 할 수 있다.

- 리소스 가져오지 않고 리소스 정보 알아내기
- 상태 코드로 개체 존재 확인하기
- 헤더 확인하여 리소스 변경 감지하기

### PUT

> 서버에 콘텐츠를 저장한다.

PUT은 콘텐츠를 변경하기에 대부분 서버는 인증을 요구한다.

### POST

> 서버에 입력 데이터를 전송한다.

HTML 폼과 같이 서버에 필요한 정보를 모아 전송한다.

### TRACE

> 클라이언트-목적지 서버 사이의 요청/응답 연쇄를 진단할 수 있다.

TRACE 요청을 받은 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다.

요청/응답 연쇄를 따라가며 자신의 메시지의 변경 내역을 확인할 수 있다.

TRACE는 엔터티 본문 대신 서버가 받은 요청만을 반환한다.

TRACE는 메서드를 구별하지 않는다. 따라서 메서드 별로 다른 서버를 거쳐가더라도 TRACE를 통해 이를 검사할 수 없다.  
TRACE 요청에 대한 처리는 중간 애플리케이션이 결정한다.

### OPTIONS

> 서버 지원 메서드 목록을 요청한다.

서버에게 특정 리소스에 대해 지원되는 메소드 목록을 요청할 수 있다.

리소스에 접근하지 않고 최선의 접근수단을 알아낼 수 있다.

### DELETE

> 서버에게 지정 리소스 삭제를 요청한다.

요청 URL로 지정한 리소스의 삭제를 요청한다.  
HTTP는 서버가 클라이언트에 알리지 않고 요청을 무시하는 것을 허용하기 때문에 삭제를 보장하지는 않는다.

### 확장 메서드

> HTTP/1.1 명세에 정의되지 않은 메서드

확장 메서드를 통해 개발자는 리소스에 대한 능력을 확장한다.  
WebDAV HTTP 확장 명세에 정의되어 있는 확장 메서드도 있지만, 정의되지 않은 메서드도 있다.

이해할 수 없는 확장 메서드에 대해서 서버는

- 종단간 행위가 망가지지 않는다면 다운스트림 서버로 전달한다.
- 그렇지 않다면 501 Not Ipmlemented 상태 코드로 응답한다.

## 4. 상태 코드

### 100-199: 정보성 상태 코드

- HTTP/1.1에서 도입
- 비교적 새롭고 복잡하다.

100 Continew 상태 코드는 서버가 요청을 받아들일 것인지 확인하기 위해 도입되었다.

- 클라이언트와 100 Continue

  - 클라이언트는 서버가 다룰 수 없는 엔터티를 서버에게 보내지 않기 위해 100 Continue를 사용한다.

  - 100 Continue 응답을 기다리겠다면 값을 100 Continue로 하는 Expect 요청 헤더를 보낸다.

  - 타임 아웃 후 클라이언트는 100 Continue 응답이 없더라도 엔터티를 보낸다.

  - 잘못된 100 Continue에 대비해야 한다.

- 프락시와 100 Continue

  - 다음 홉이 HTTP/1.1을 따르거나 홉의 버전 정보를 모른다면 Expect 헤더를 포함해 요청을 전달한다.

  - 다음 홉이 1.1 이전 HTTP를 따른다면 417 Expectation Failed 에러로 응답한다.

  - 1.1 이전 HTTP 클라이언트 대신 프록시가 1.1 이전 HTTP 요청을 넣었다면 1.1 이전 HTTP 응답을 클라이언트에 전달하면 안된다.

### 200-299: 성공 상태 코드

성공 상태 코드 배열은 각각 다른 요청에 대응한다.

### 300-399: 리다이렉션 상태 코드

클라이언트가 접근한 리소스의 다른 위치를 제공하거나 대안 응답을 제공한다.  
리다이렉션 상태 코드는 다음 역할을 할 수 있다.

- 리다이렉션 상태코드와 Location(선택)을 보내 브라우저가 새 위치로 이동할 수 있다.
- 로컬의 리소스 복사본이 서버의 원본과 동일한 버전인지 확인한다.

302, 303, 307 상태 코드는 HTTP 프로토콜 버전에 따라 쓰인다.

- HTTP/1.0 클라이언트 <- HTTP/1.0 서버  
  302 상태 코드 전송
  - 클라이언트는 리다이렉트 URL에 대해 GET 요청한다
- HTTP/1.1 클라이언트 <- HTTP/1.1 서버  
  307 상태 코드 전송
  - 클라이언트는 리다이렉트 URL에 대해 GET 요청한다

혼란을 막기 위해 HTTP/1.1 명세는 HTTP/1.1 클라이언트의 일시적 리다이렉트를 위해 302 대신 307 상태 코드를 사용하게 한다.

### 400-499: 클라이언트 에러 상태 코드
존재하지 않는 URL에 대한 요청과 같이 클라이언트가 서버가 다룰 수 없는 요청을 보냈을 때 전달되는 상태 코드다.  
404를 비롳한 몇 에러를 제외하고 대부분의 클라이언트 에러는 브라우저에 의해 처리된다.

### 500-599: 서버 에러 상태 코드
클라이언트-서버 혹은 프락시-서버 간에 서버의 에러가 발생하면 전달되는 상태 코드다.

## 5. 헤더

### 일반 헤더
> 클라이언트 서버 양쪽 모두 사용하는 헤더. 
메시지에 대한 기본적인 정보를 제공한다

일반 캐시 헤더
* 로컬 복사본으로 객체 캐시하게 하는 헤더
* HTTP/1.0부터 도입

### 요청 헤더
> 요청 메시지에 대한 헤더

Accept 관련 헤더
* 클라이언트가 서버에세 자신의 선호와 능력을 알린다.
* 불가능한 요청으로 인한 시간과 대역폭 낭비를 막는다.

조건부 요청 헤더
* 서버가 요청에 응답하기 전 확인할 제약을 추가한다.

요청 보안 헤더
* 클라이언트가 서버에 제공하는 인증 관련 헤더

프락시 요청 헤더
* 프락시 기능을 돕기 위한 헤더

### 웅덥 헤더
> 응답 메세지에 대한 헤더. 클라이언트에게 부가 정보 제공

협상 헤더
* 클라이언트가 표현 방식을 선택할 때 서버가 협상 가능한 리소스 정보를 전달하는 헤더

응답 헤더
* 클라이언트에 요구하는 인증 관련 헤더

### 엔터티 헤더
> 엔터티에 대한 광범위한 정보 제공

엔터티 헤더는 엔터티와 내용물의 개체 타입, 유효 메서드 등 엔터티에 대한 광범위한 정보를 제공한다.

콘텐츠 헤더
* 엔터티 종류, 크기 등 구체적인 정보 제공
* 웹브라우저는 콘텐츠 헤더를 통해 객체 표현 방법을 결정한다.

엔터티 캐싱 헤더
* 캐시 사본의 유효성 정보 등 엔터티 캐싱에 대한 정보 제공
