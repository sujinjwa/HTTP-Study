# 블로그 링크

[블로그 링크](https://velog.io/@sujinjwa/HTTP-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C-3%EC%9E%A5.-HTTP-%EB%A9%94%EC%8B%9C%EC%A7%80)

블로그에서 보는 것이 더 가독성이 좋습니다~!

<br />

---

# 3장. HTTP 메시지

## 1. 메시지의 흐름

### 1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다

메시지가 **원 서버로 항하는 것은 인바운드로 이동**하는 것이고, 모든 처리가 끝난 뒤에 **메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동**하는 것이다.

![](https://velog.velcdn.com/images/sujinjwa/post/8751dd53-c42d-4828-b54a-355940137403/image.png)


<br />

### 1.2 다운스트림으로 흐르는 메시지

HTTP 메시지는 요청 메시지냐 응답 메시지냐에 관계없이 **다운스트림으로 흐른다**.

메시지의 발송자는 **수신자의 업스트림**이다.

![](https://velog.velcdn.com/images/sujinjwa/post/d55d9b68-2ed8-4565-a0c5-516b33dee18d/image.png)

위 그림에서, 요청에서는 프락시 1이 프락시 3의 **업스트림**이지만 응답에서는 프락시 3의 **다운스트림**이다.


<br />

## 2. 메시지의 각 부분

메시지를 **시작줄, 헤더 블록, 본문** 이렇게 세 부분으로 이루어진다.

![](https://velog.velcdn.com/images/sujinjwa/post/ec55000f-16f7-4eeb-9e8a-cfab9cc4db7c/image.png)

- 시작줄 : 어떤 메시지인지 서술
  - 시작줄과 헤더는 줄바꿈 문자열(`CRLF`)로 분리되어 있다

- 헤더 : 본문에 대한 정보 제공
  - `Content-Type` : 본문이 무엇인지 (ex. 플레인 텍스트 문서)
  - `Content-Length` : 본문의 크기 (ex. 19바이트)

- 본문 : 메시지 내용

<br />

### 2.1 메시지 문법

HTTP 메시지는 요청, 응답 메시지 중 하나인데, 요청과 응답 모두 기본적으로 구조가 같다.

- 요청 메시지의 형식

```shell
<메서드>  <요청 URL>  <버전>
<헤더>

<엔터티 본문>
```

- 응답 메시지의 형식 (시작줄만 다르다)

```shell
<버전>  <상태코드>  <사유 구절>
<헤더>

<엔터티 본문>
```

- 예)
![](https://velog.velcdn.com/images/sujinjwa/post/4e2582a2-ce15-4e4f-9d8b-07bfc1f914fe/image.png)


---

위의 메시지를 이루는 각 부분에 대한 설명은 다음과 같다.

- **메서드** : 클라이언트 측에서 **서버가 리소스에 대해 수행해주길 바라는 동작**
  - ex) `GET`, `HEAD`, `POST`

- **요청 URL** : 요청 대상이 되는 리소스를 지칭하는 URL (요청 동작에 대한 대상)

- **버전** : 이 메시지에서 사용 중인 **HTTP의 버전**
  - 형식: `HTTP/<메이저>.<마이너>`
  
- **상태 코드** : 요청 중에 무엇이 일어났는지 설명하는 세 자리 숫자. 성공, 에러 등 나타냄

- **사유 구절(reason-phrase)** : 숫자로된 상태코드를 사람이 이해할 수 있게 설명해주는 짧은 문구
  - ex) 상태코드가 `200`이면 사유 구절은 `OK`

- **헤더**들 : 이름, 콜론(`:`), 선택적 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들
  - 헤더는 빈 줄(`CRLF`)로 끝남 -> 헤더 목록의 끝과 엔터티 본문의 시작 표시

- **엔터티 본문** : 메시지 내용
  - 모든 메시지가 엔터티 본문을 갖는 것은 아님. 가끔 그냥 `CRLF`로 끝남.
  
  ---
  
  > 주의! 🌟 헤더나 엔터티 본문이 없더라도 **HTTP 헤더의 집합은 항상 빈 줄(그냥 `CRLF`)로 끝나야 한다**
  
  역사적으로 많은 클라이언트와 서버가 엔터티 본문이 없으면 실수로 마지막 `CRLF`를 빠뜨리곤 했다.
  
  그래서 클라이언트와 서버는, 규칙을 잘 지키지 않는 구현체와의 호환을 위해 마지막 `CRLF` 없이 끝나는 메시지도 받아들일 수 있어야 한다.

<br />


### 2.2 시작줄

#### 2.2.1 요청줄

요청 메시지의 시작줄은, 위에서 봤듯 `메서드`, `요청 URL`, `HTTP 버전`으로 이루어진다.

```shell
<메서드>  <요청 URL>  <버전>
```

각 필드는 공백으로 구분된다.

ex) `GET /test/hi-there.txt HTTP/1.1`

---

#### 2.2.2 응답줄

응답 메시지의 시작줄에는 `HTTP 버전`, `숫자로 된 상태코드`, `수행 상태에 대해 설명해주는 텍스트로 된 사유 구절`으로 이루어진다.

```shell
<버전>  <상태코드>  <사유 구절>
```

각 필드는 공백으로 구분된다.

ex) `HTTP/1.0 200 OK`

---

#### 2.2.3 메서드

> 메서드 : 요청의 시작줄 맨 앞에 붙으며, 서버에게 무엇을 해야 하는지 말해준다

- HTTP 명세 (요청 메서드의 집합)

| 메서드 | <center>설명</center> | 메시지 본문이 있는가? |
| :-: | :- | :-: |
| GET | 서버에게 리소스 달라고 요청하여, 서버에서 어떤 문서를 가져온다 | 없음 |
| HEAD | 서버에서 어떤 문서에 대한 헤더만 가져온다 | 없음 |
| POST | 서버가 처리해야 할 데이터를 보낸다 (ex. HTML 폼으로 입력 데이터 전송 시 사용) | 있음 |
| PUT | 서버가 요청 URL의 이름대로 요청의 본문으로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체한다 | 있음 |
| TRACE | 메세지가 방화벽, 프락시, 게이트웨이 등을 거쳐 서버에 도달하는 과정을 추적한다 (주로 진단을 위해 사용) | 없음 |
| OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다 | 없음 |
| DELETE | 서버에에서 리소스를 제거한다 | 없음 |

<br />

--- 

> 상태 코드 : 응답의 시작줄에 담겨 반환되며, 클라이언트에게 무엇이 일어났는지 말해준다

클라이언트가 HTTP 서버에게 요청 메시지를 보낼 때, 많은 일이 일어난다.

요청이 성공할 수도, 요청한 리소스가 발견되지 않을 수도, 리소스에 접근할 권한이 없을 수도 있다. 

이러한 다양한 상태들을 세 자리 숫자로 된 코드값을 기준으로 묶어 나타낸다.

- 상태 코드의 종류 🌟

| 전체 범위 | 정의된 범위 | 분류 |
| :-: | :-: | :-: |
| 100 - 199 | 100 - 101 | 정보성 상태 코드 |
| 200 - 299 | 200 - 206 | 성공 상태 코드 |
| 300 - 399 | 300 - 305 | 리다이렉션 상태 코드 |
| 400 - 499 | 400 - 415 | 클라이언트 에러 상태 코드 |
| 500 - 599 | 500 - 505 | 서버 에러 상태 코드 |


> 더 자세한 [상태 코드 종류 from MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)

---

> 사유 구절 : 상태 코드에 대한 글로 된 설명을 제공한다

- 예) `HTTP/1.0 200 OK`에서 `OK`가 사유 구절이다

---

> 버전 번호 : 애플리케이션이 따르는 프로토콜 버전을 의미하고, `HTTP/x.y` 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다

- 버전 번호는 애플리케이션이 지원하는 **가장 높은 HTTP 버전**이다

  - 즉, 응답의 프로토콜 버전이 `HTTP/1.1`이라면, 응답 보낸 애플리케이션이 `HTTP/1.1`까지 이해할 수 있음을 의미한다

- 버전 번호는 분수로 다루어지지 않는다

  - 즉, `HTTP/2.22`와 `HTTP/2.3` 중 `22`가 `3`보다 큰 숫자이므로, `HTTP/2.22`가 더 크다

<br />

### 2.3 헤더

시작줄 다음에 0개, 1개, 혹은 여러 개의 HTTP 헤더가 오며, 요청과 응답 메시지에 추가 정보를 더해준다.

기본적으로 **이름/값 쌍**의 목록이다.

#### 헤더 분류

1) **일반 헤더** : 요청과 응답 양쪽에 모두 나타날 수 있음, 메시지에 대한 아주 기본적인 정보 제공

  - ex) 메시지 생성 일시 (`Date: Tue, 3, Oct 2024 02:14:00 GMT`)

2) **요청 헤더** : 요청에 대한 부가 정보 제공

  - ex) 서버에게 클라이언트가 받고자 하는 데이터 타입 등 (`Accept: */*`)

3) **응답 헤더** : 응답에 대한 부가 정보 제공

  - ex) 클라이언트가 어떤 종류의 서버와 대화하고 있는지 등 (`Server: Tiki-Hut/1.0`)

4) **Entity 헤더** : 본문 크기와 콘텐츠, 본문 타입, 혹은 리소스 그 자체를 서술

  - ex) `Content-Type: text/html; charset=iso-latin-1`

5) **확장 헤더** : 명세에 정의되지 않은 새로운 헤더

---

#### 흔히 쓰이는 헤더의 예

| 헤더의 예 | 설명 |
| :-: | :-: |
| Date: Tue, 3 Oct 1997 02:16:03 GMT | 서버가 응답을 만들어 낸 시각 |
| Content-length: 15040 | 15,040바이트의 데이터를 포함한 엔터티 본문 |
| Content-type: image/gif | 엔터티 본문은 GIF 이미지다 |
| Accept: image/gif, image/jpeg, text/html | 클라이언트는 GIF, JPEG 이미지와 HTML을 받아들일 수 있다 |

---

(2.3 ~ 2.4 생략)

<br />

### 2.5 버전 0.9 메시지

HTTP 버전 0.9는 HTTP 프로토콜의 **초기 버전**이다.

HTTP 버전 0.9 메시지도 요청과 응답으로 이루어져 있지만, 요청은 **메서드와 요청 URL**만 가지고 있으며(상태 코드, 사유 구절, 헤더 모두 X), 응답은 오직 **엔터티로만** 되어 있다.

HTTP/0.9로는 다양한 상황에 대응할 수 없으며, 요즘 대부분의 애플리케이션들을 구현할 수 없다.
